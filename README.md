# credits
проект по анализу заемщиков для кредитного отдела
Исходные данные  — статистика платёжеспособности.


Изучил общую информацию<br>
import pandas as pd <br>
data = pd.read_csv('/datasets/data.csv')<br>
data.info()<br>
<class 'pandas.core.frame.DataFrame'><br>
RangeIndex: 21525 entries, 0 to 21524<br>
Data columns (total 12 columns):<br>
children            21525 non-null int64<br>
days_employed       19351 non-null float64<br>
dob_years           21525 non-null int64<br>
education           21525 non-null object<br>
education_id        21525 non-null int64<br>
family_status       21525 non-null object<br>
family_status_id    21525 non-null int64<br>
gender              21525 non-null object<br>
income_type         21525 non-null object<br>
debt                21525 non-null int64<br>
total_income        19351 non-null float64<br>
purpose             21525 non-null object<br>
dtypes: float64(2), int64(5), object(5)<br>


Проблемы обнаруженные при выводе результата метода info():

В колонке "Трудовой стаж"(days_employed) значения указаны в формате вещественного типа. Необходимо перевести тип данных в целочисленный, так как в зачет в трудового стажа идут только полностью отработанные дни.

Количество записей (19351) в колонках "Трудовой стаж" (days_employed) и "Ежемесячный доход"(total_income) не соответствует общему количеству записей (21525), а значит в колонках есть пропуски.

Возможная причина появления пропусков  в значениях колонки "Тип занятости". По моей гипотезе отсутствие трудового статуса и ежемесячного дохода может быть у неработающих людей, например : студенты или просто никогда не работавшие люди. 

Предобработка данных<br>
Обработка пропусков<br>
number_of_passes_in_days_employed = data['days_employed'].isna().sum()<br>
number_of_passes_in_total_income = data['total_income'].isna().sum()<br>
if number_of_passes_in_days_employed == number_of_passes_in_total_income:<br>
    print(f'Количество пропусков в колонке "Трудовой стаж" равно количеству пропусков в колонке "Ежемесячный доход" - {number_of_passes_in_total_income}')<br>
else:<br>
    print(f"Количество пропусков в колонках не совпадает,\nКоличество пропусков в колонке Трудовой стаж до обработки - {number_of_passes_in_days_employed},\nКоличество пропусков в колонке Ежемесячный доход до обработки - {number_of_passes_in_total_income}\n")<br>
Количество пропусков в колонке "Трудовой стаж" равно количеству пропусков в колонке "Ежемесячный доход" - 2174<br>
people_with_nan = data[data['days_employed'].isna()]<br>
people_with_nan.head(15)<br>
children	days_employed	dob_years	education	education_id	family_status	family_status_id	gender	income_type	debt	total_income	purpose<br>
12	0	NaN	65	среднее	1	гражданский брак	1	M	пенсионер	0	NaN	сыграть свадьбу<br>
26	0	NaN	41	среднее	1	женат / замужем	0	M	госслужащий	0	NaN	образование<br>
29	0	NaN	63	среднее	1	Не женат / не замужем	4	F	пенсионер	0	NaN	строительство жилой недвижимости<br>
41	0	NaN	50	среднее	1	женат / замужем	0	F	госслужащий	0	NaN	сделка с подержанным автомобилем<br>
55	0	NaN	54	среднее	1	гражданский брак	1	F	пенсионер	1	NaN	сыграть свадьбу<br>
65	0	NaN	21	среднее	1	Не женат / не замужем	4	M	компаньон	0	NaN	операции с коммерческой недвижимостью<br>
67	0	NaN	52	высшее	0	женат / замужем	0	F	пенсионер	0	NaN	покупка жилья для семьи<br>
72	1	NaN	32	высшее	0	женат / замужем	0	M	госслужащий	0	NaN	операции с коммерческой недвижимостью<br>
82	2	NaN	50	высшее	0	женат / замужем	0	F	сотрудник	0	NaN	жилье<br>
83	0	NaN	52	среднее	1	женат / замужем	0	M	сотрудник	0	NaN	жилье<br>
90	2	NaN	35	высшее	0	женат / замужем	0	F	сотрудник	0	NaN	операции с жильем<br>
94	1	NaN	34	высшее	0	гражданский брак	1	F	компаньон	0	NaN	на проведение свадьбы<br>
96	0	NaN	44	СРЕДНЕЕ	1	женат / замужем	0	F	сотрудник	0	NaN	покупка жилой недвижимости<br>
97	0	NaN	47	высшее	0	женат / замужем	0	F	сотрудник	0	NaN	профильное образование<br>
120	0	NaN	46	среднее	1	женат / замужем	0	F	сотрудник	0	NaN	высшее образование<br>
Сгруппирую людей без стажа и дохода в отдельный датафрейм. В срезе данных присутствую разные параметры. Значит зависимости отсутствия стажа и дохода от других параметров нет. Гипотеза не подтвердилась. Возможно пропуски допущены по технологическим причинам. Проверю значение в колонках в общем датафрейме на предмет ошибок значений.<br>

data.head()<br>
children	days_employed	dob_years	education	education_id	family_status	family_status_id	gender	income_type	debt	total_income	purpose<br>
0	1	-8437.673028	42	высшее	0	женат / замужем	0	F	сотрудник	0	253875.639453	покупка жилья<br>
1	1	-4024.803754	36	среднее	1	женат / замужем	0	F	сотрудник	0	112080.014102	приобретение автомобиля<br>
2	0	-5623.422610	33	Среднее	1	женат / замужем	0	M	сотрудник	0	145885.952297	покупка жилья<br>
3	3	-4124.747207	32	среднее	1	женат / замужем	0	M	сотрудник	0	267628.550329	дополнительное образование<br>
4	0	340266.072047	53	среднее	1	гражданский брак	1	F	пенсионер	0	158616.077870	сыграть свадьбу<br>
Кроме пропусков присутствуют отрицательные значения. Возможно данные были перенесены в таблицу со знаком минус ошибочно. Возможно подобная ошибка есть и в других количественных значениях. Избавлюсь от отрицательного знака во всеx числовых значениях, и приведу все текстовые записи к единому регистру.<br>

for column in data.columns:<br>
    if data[column].dtypes == object:<br>
        data[column] = data[column].str.lower()<br>
    if (data[column].dtypes == 'int64') or (data[column].dtypes == 'float64'):<br>
        data[column] = abs(data[column])<br>
data.head()<br>
children	days_employed	dob_years	education	education_id	family_status	family_status_id	gender	income_type	debt	total_income	purpose<br>
0	1	8437.673028	42	высшее	0	женат / замужем	0	f	сотрудник	0	253875.639453	покупка жилья<br>
1	1	4024.803754	36	среднее	1	женат / замужем	0	f	сотрудник	0	112080.014102	приобретение автомобиля<br>
2	0	5623.422610	33	среднее	1	женат / замужем	0	m	сотрудник	0	145885.952297	покупка жилья<br>
3	3	4124.747207	32	среднее	1	женат / замужем	0	m	сотрудник	0	267628.550329	дополнительное образование<br>
4	0	340266.072047	53	среднее	1	гражданский брак	1	f	пенсионер	0	158616.077870	сыграть свадьбу<br>
В данных о трудовом стаже есть записи, чьи значения превышают продолжительность жизни. Возможно при заполнение была допущена ошибка в постановке разряда. По статистике максимальный трудовой стаж составляет 20 лет или 7300 дней. Это 4 разряда. Найду все записи, значение которых больше этого показателя, и приведу в допустимый разряд.<br>

df_with_days_employed = data[data['days_employed'] > 20000]<br>
for val in df_with_days_employed['days_employed']:<br>
    if len(set(str(val))) > 4:<br>
        new_val = val / 100<br>
        data['days_employed'] = data['days_employed'].replace(val, new_val)<br>
data.head()<br>
children	days_employed	dob_years	education	education_id	family_status	family_status_id	gender	income_type	debt	total_income	purpose<br>
0	1	8437.673028	42	высшее	0	женат / замужем	0	f	сотрудник	0	253875.639453	покупка жилья<br>
1	1	4024.803754	36	среднее	1	женат / замужем	0	f	сотрудник	0	112080.014102	приобретение автомобиля<br>
2	0	5623.422610	33	среднее	1	женат / замужем	0	m	сотрудник	0	145885.952297	покупка жилья<br>
3	3	4124.747207	32	среднее	1	женат / замужем	0	m	сотрудник	0	267628.550329	дополнительное образование<br>
4	0	3402.660720	53	среднее	1	гражданский брак	1	f	пенсионер	0	158616.077870	сыграть свадьб<br>у
Посмотрим колонку с возрастом.<br>

age_with_error = data[(data['dob_years'] <= 0) | (data['dob_years'] > 80)]<br>
age_with_error['dob_years'].value_counts()<br>
0    101<br>
Name: dob_years, dtype: int64<br>
В колонку присутствуют нулевые значения. Учитывая большую вариативность параметров, не вижу возможным корректно заполнить такой пропуск. Исходя из отношения количества нулевых записей к общему, удаление таких данных не повлияет на дальнейшие расчеты.<br>

data = data[data.dob_years != 0]<br>
Заполню пропуски в колонках со стажем и доходом медианным значением. Пропуски поделю по группам, основанным на типе занятости. Каждой группе по типу занятости будет соответствовать свое медианное значение.<br>
<br>
data['income_type_id'] = data['income_type'].map(<br>
    {'студент': 0, 'безработный': 1, 'пенсионер': 2,
                    'в декрете':3, 'госслужащий': 4, 'сотрудник':5, 'компаньон':6, 'предприниматель':7} )<br>
data.corr()<br>
children	days_employed	dob_years	education_id	family_status_id	debt	total_income	income_type_id<br>
children	1.000000	-0.068430	-0.179248	-0.013002	-0.091234	0.018239	0.017571	0.123174<br>
days_employed	-0.068430	1.000000	0.382115	0.004821	-0.066990	-0.075188	-0.006106	-0.256665<br>
dob_years	-0.179248	0.382115	1.000000	0.065190	-0.069103	-0.071919	-0.055998	-0.562510<br>
education_id	-0.013002	0.004821	0.065190	1.000000	0.009357	0.052633	-0.179046	-0.090409<br>
family_status_id	-0.091234	-0.066990	-0.069103	0.009357	1.000000	0.020950	-0.008970	0.008447<br>
debt	0.018239	-0.075188	-0.071919	0.052633	0.020950	1.000000	-0.012421	0.035592<br>
total_income	0.017571	-0.006106	-0.055998	-0.179046	-0.008970	-0.012421	1.000000	0.177075<br>
income_type_id	0.123174	-0.256665	-0.562510	-0.090409	0.008447	0.035592	0.177075	1.000000<br>
income_type = data[data['days_employed'].isna()]['income_type'].unique()<br>
for val in income_type:<br>
    median_for_total_income = data[data['income_type'] == val]['total_income'].median()<br>
    median_for_days_employed = data[data['income_type'] == val]['days_employed'].median()<br>
    data.loc[((data.income_type == val) & data.total_income.isna()), 'total_income'] = median_for_total_income<br>
    data.loc[((data.income_type == val) & data.days_employed.isna()), 'days_employed'] = median_for_days_employed<br>
    
print('Количество пропусков в колонке "Трудовой стаж" после обработки - ', (data['days_employed'].isna().sum()), '\n')<br>
print('Количество пропусков в колонке "Ежемесячный доход" после обработки - ', (data['total_income'].isna().sum()), '\n')<br>
Количество пропусков в колонке "Трудовой стаж" после обработки -  0 <br>

Количество пропусков в колонке "Ежемесячный доход" после обработки -  0 <br>

<br>

Обработка пропусков в колонках "Трудовой стаж" и "Ежемесячный доход".<br>

Пропуски в колонках могли быть связаны с технологической ошибкой. Для заполнения пропусков в количественных переменных было выбранно медианное значение. Ее велична расчитана для каждого типа занятости отдельно. Среднее значение не использовалось, потому что могло бы некорректно охарактеризовать данные, если некоторые значения сильно выдавались бы среди большинства.<br>

Замена типа данных<br>
data['days_employed'] = data['days_employed'].astype('int')<br>
data['days_employed'].head()<br>
0    8437<br>
1    4024<br>
2    5623<br>
3    4124<br>
4    3402<br>
Name: days_employed, dtype: int64<br>

Замена типа данных в колонке "Трудовой стаж".<br>

Вещественный тип данных был заменен на целочисленный, так как в зачет трудового стажа идут полностью отработанные года, месяца и дни. В нашем случае дни, поэтому все числа после запятой не будут иметь значения для расчета скоринга.<br>

Обработка дубликатов<br>
print('Количетсво записей дубликатов - ',data.duplicated().sum())<br>
Количетсво записей дубликатов -  71<br>
data = data.drop_duplicates().reset_index(drop=True)<br>
data.shape<br>
(21353, 13)<br>


Обработка дубликатов.<br>

Всего в этом датафрейме обнаружена 71 дублированная запись. Дублирующие записи могли появится в результате ошибки ввода информации. Для обнаружения явных дубликатов использовался метод duplicated() + метод sum() для подсчета их количества. Для удаления дубликатов использовал метод drop_duplicated() и метод resete_index с параметром drop=True. Такая связка позволит перезаписать датафрейм с обычным порядком индексов и без создания отдельной колонки со старыми индексами.<br>

Лемматизация<br>
Для начала посмотрю на значения в клонке "Цель".<br>

unique_purposes = data['purpose'].unique()<br>
print(unique_purposes)<br>
print('\nВсего уникальных значений - ',len(unique_purposes))<br>
['покупка жилья' 'приобретение автомобиля' 'дополнительное образование'<br>
 'сыграть свадьбу' 'операции с жильем' 'образование'<br>
 'на проведение свадьбы' 'покупка жилья для семьи' 'покупка недвижимости'<br>
 'покупка коммерческой недвижимости' 'покупка жилой недвижимости'<br>
 'строительство собственной недвижимости' 'недвижимость'<br>
 'строительство недвижимости' 'на покупку подержанного автомобиля'<br>
 'на покупку своего автомобиля' 'операции с коммерческой недвижимостью'<br>
 'строительство жилой недвижимости' 'жилье'<br>
 'операции со своей недвижимостью' 'автомобили' 'заняться образованием'<br>
 'сделка с подержанным автомобилем' 'получение образования' 'автомобиль'<br>
 'свадьба' 'получение дополнительного образования' 'покупка своего жилья'<br>
 'операции с недвижимостью' 'получение высшего образования'<br>
 'свой автомобиль' 'сделка с автомобилем' 'профильное образование'<br>
 'высшее образование' 'покупка жилья для сдачи' 'на покупку автомобиля'м
 'ремонт жилью' 'заняться высшим образованием']<br>

Всего уникальных значений -  38<br>
Некоторые цели повторяются и может быть выражена словосочетаниями-синонимами. Посчитю часто упоминающиеся цели, для этого лемматизирую каждое значение и соединю в общий список и с помощью метода Counter() проверю сколько раз повторяется каждое слово.<br>

from pymystem3 import Mystem<br>
from collections import Counter<br>


list_with_all_purposes = []<br>
m = Mystem()<br>
for purpose in unique_purposes:<br>
    lemmas = m.lemmatize(purpose)<br>
    lemmas.pop(-1)<br>
    list_with_all_purposes.extend(lemmas)<br>
print(Counter(list_with_all_purposes))<br>
Counter({' ': 59, 'покупка': 10, 'недвижимость': 10, 'автомобиль': 9, 'образование': 9, 'жилье': 7, 'с': 5, 'операция': 4, 'на': 4, 'свой': 4, 'свадьба': 3, 'строительство': 3, 'получение': 3, 'высокий': 3, 'дополнительный': 2, 'для': 2, 'коммерческий': 2, 'жилой': 2, 'заниматься': 2, 'сделка': 2, 'приобретение': 1, 'сыграть': 1, 'проведение': 1, 'семья': 1, 'собственный': 1, 'подержать': 1, 'со': 1, 'подержанный': 1, 'профильный': 1, 'сдача': 1, 'ремонт': 1})<br>
В наборе присутствует слово и частота его повторения. Некоторыми способами можно удалить из списка с целями все глаголы и местоимения, но хорощих способов для такого процесса не нашел. В ручном режиме проанализировал и взял основные слова цели для составления функции. Она будет обрабатывать цель из колонки и вовзвращать отформатированное основное значение для новой колонки.<br>

def formatting_the_purpose(val):<br>
    lemmas = m.lemmatize(val)<br>
    if ('строительство' in lemmas):<br>
        return 'строительство'
    if ('недвижимость' in lemmas) or ('жилье' in lemmas):<br>
        return 'недвижимость'<br>
    if 'автомобиль' in lemmas:<br>
        return 'автотранспорт'<br>
    if 'свадьба' in lemmas:<br>
        return 'свадьба'<br>
    if 'ремонт' in lemmas:<br>
        return 'ремонт'<br>
    if 'образование' in lemmas:<br>
        return 'образование'<br>
    return 'цель не определена'<br>


data['target'] = data['purpose'].apply(formatting_the_purpose)<br>
data.head(20)<br>
children	days_employed	dob_years	education	education_id	family_status	family_status_id	gender	income_type	debt	total_income	purpose	income_type_id	target<br>
0	1	8437	42	высшее	0	женат / замужем	0	f	сотрудник	0	253875.639453	покупка жилья	5	недвижимость<br>
1	1	4024	36	среднее	1	женат / замужем	0	f	сотрудник	0	112080.014102	приобретение автомобиля	5	автотранспорт<br>
2	0	5623	33	среднее	1	женат / замужем	0	m	сотрудник	0	145885.952297	покупка жилья	5	недвижимость<br>
3	3	4124	32	среднее	1	женат / замужем	0	m	сотрудник	0	267628.550329	дополнительное образование	5	образование<br>
4	0	3402	53	среднее	1	гражданский брак	1	f	пенсионер	0	158616.077870	сыграть свадьбу	2	свадьба<br>
5	0	926	27	высшее	0	гражданский брак	1	m	компаньон	0	255763.565419	покупка жилья	6	недвижимость<br>
6	0	2879	43	высшее	0	женат / замужем	0	f	компаньон	0	240525.971920	операции с жильем	6	недвижимость<br>
7	0	152	50	среднее	1	женат / замужем	0	m	сотрудник	0	135823.934197	образование	5	образование<br>
8	2	6929	35	высшее	0	гражданский брак	1	f	сотрудник	0	95856.832424	на проведение свадьбы	5	свадьба<br>
9	0	2188	41	среднее	1	женат / замужем	0	m	сотрудник	0	144425.938277	покупка жилья для семьи	5	недвижимость<br>
10	2	4171	36	высшее	0	женат / замужем	0	m	компаньон	0	113943.491460	покупка недвижимости	6	недвижимость<br>
11	0	792	40	среднее	1	женат / замужем	0	f	сотрудник	0	77069.234271	покупка коммерческой недвижимости	5	недвижимость<br>
12	0	3651	65	среднее	1	гражданский брак	1	m	пенсионер	0	118557.179415	сыграть свадьбу	2	свадьба<br>
13	0	1846	54	неоконченное высшее	2	женат / замужем	0	f	сотрудник	0	130458.228857	приобретение автомобиля	5	автотранспорт<br>
14	0	1844	56	высшее	0	гражданский брак	1	f	компаньон	1	165127.911772	покупка жилой недвижимости	6	недвижимость<br>
15	1	972	26	среднее	1	женат / замужем	0	f	сотрудник	0	116820.904450	строительство собственной недвижимости	5	строительство<br>
16	0	1719	35	среднее	1	женат / замужем	0	f	сотрудник	0	289202.704229	недвижимость	5	недвижимость<br>
17	0	2369	33	высшее	0	гражданский брак	1	m	сотрудник	0	90410.586745	строительство недвижимости	5	строительство<br>
18	0	4002	53	среднее	1	вдовец / вдова	2	f	пенсионер	0	56823.777243	на покупку подержанного автомобиля	2	автотранспорт<br>
19	0	10038	48	среднее	1	в разводе	3	f	сотрудник	0	242831.107982	на покупку своего автомобиля	5	автотранспорт<br>
<br>

Лемматизация.<br>

Для лемматизация использовал библиотеку pymystem3, она возвращает список лемматизированных слов для каждого значения колонки, так же библиотека работает и с несуществующими словами. Предварительно получил список всех уникальных значений колонки, а затем лемматизировал эти значения, соеденил в общий список и посмотрел частоту повторения для исключения синонимов-дубликтов. С помощью функции в цикле лемматизировал каждое значение в колонке purpose и получил новое значение, которое добавил в дополнительную колонку методом aplly().<br>

Категоризация данных<br>
Категоризировать будущих заемщиков буду на основе их трудового стажа, работы, уровня дохода, возраста, семейного положения, наличия детей, образования, а так же по проблемам с возвратом кредитов. Перспективными заемщиками будем считать людей с высшим образованием, в браке и без детей. Сначала определим допустимый уровень дохода и трудовой стаж. Для их определения буду использовать метод median().<br>

median_income = data['total_income'].median()<br>
median_employed = data['days_employed'].median()<br>
print('Медианный доход - ', median_income)<br>
print('Медианный трудовой стаж - ', median_employed)<br>
Медианный доход -  142594.39684740017<br>
Медианный трудовой стаж -  1998.0<br>
Теперь использую функцию, которая будет принимать параметры, анализировать их и выдавать статус платежеспособности клинета.<br>

def get_status(row):<br>
    cnt = 0<br>
    if ((row['days_employed'] >= median_employed) and<br>
       (row['income_type'] in ['сотрудник', 'компаньон', 'госслужащий', 'предприниматель'])):<br>
        cnt += 2<br>
    if (21 <= row['dob_years'] <= 65) and (row['education'] in ['высшее', 'ученая степень' ]):<br>
        cnt += 2<br>
    if row['total_income'] >= median_income:<br>
        cnt += 1<br>
    if (row['family_status'] in ['женат/замужем', 'гражданский брак', 'не женат / не замужем']) and (row['children'] <= 1):<br>
        cnt += 2<br>
    if row['debt'] == 0:<br>
        cnt += 1<br>
    if row['income_type'] in ['студент', 'безработный', 'пенсионер']:<br>
        cnt -= 1<br>
    if row['debt'] == 1:<br>
        cnt -= 2<br>
    procent = (cnt / 8) * 100<br>
    if procent >= 50:<br>
        return 'платежеспособен'<br>
    elif procent <= 50:<br>
        return 'неплатежеспособен'<br>

    
Применю функцию к строкам датафрейма с помощью метода apply() с параметром axis=1, что бы входными значениями для функции стали строки.<br>

data['solvency_status'] = data.apply(get_status, axis=1)<br>
data.head(20)<br>
children	days_employed	dob_years	education	education_id	family_status	family_status_id	gender	income_type	debt	total_income	purpose	income_type_id	target	<br>solvency_status<br>
0	1	8437	42	высшее	0	женат / замужем	0	f	сотрудник	0	253875.639453	покупка жилья	5	недвижимость	платежеспособен<br>
1	1	4024	36	среднее	1	женат / замужем	0	f	сотрудник	0	112080.014102	приобретение автомобиля	5	автотранспорт	неплатежеспособен<br>
2	0	5623	33	среднее	1	женат / замужем	0	m	сотрудник	0	145885.952297	покупка жилья	5	недвижимость	платежеспособен<br>
3	3	4124	32	среднее	1	женат / замужем	0	m	сотрудник	0	267628.550329	дополнительное образование	5	образование	платежеспособен<br>
4	0	3402	53	среднее	1	гражданский брак	1	f	пенсионер	0	158616.077870	сыграть свадьбу	2	свадьба	неплатежеспособен<br>
5	0	926	27	высшее	0	гражданский брак	1	m	компаньон	0	255763.565419	покупка жилья	6	недвижимость	платежеспособен<br>
6	0	2879	43	высшее	0	женат / замужем	0	f	компаньон	0	240525.971920	операции с жильем	6	недвижимость	платежеспособен<br>
7	0	152	50	среднее	1	женат / замужем	0	m	сотрудник	0	135823.934197	образование	5	образование	неплатежеспособен<br>
8	2	6929	35	высшее	0	гражданский брак	1	f	сотрудник	0	95856.832424	на проведение свадьбы	5	свадьба	платежеспособен<br>
9	0	2188	41	среднее	1	женат / замужем	0	m	сотрудник	0	144425.938277	покупка жилья для семьи	5	недвижимость	платежеспособен<br>
10	2	4171	36	высшее	0	женат / замужем	0	m	компаньон	0	113943.491460	покупка недвижимости	6	недвижимость	платежеспособен<br>
11	0	792	40	среднее	1	женат / замужем	0	f	сотрудник	0	77069.234271	покупка коммерческой недвижимости	5	недвижимость	неплатежеспособен<br>
12	0	3651	65	среднее	1	гражданский брак	1	m	пенсионер	0	118557.179415	сыграть свадьбу	2	свадьба	неплатежеспособен<br>
13	0	1846	54	неоконченное высшее	2	женат / замужем	0	f	сотрудник	0	130458.228857	приобретение автомобиля	5	автотранспорт	неплатежеспособен<br>
14	0	1844	56	высшее	0	гражданский брак	1	f	компаньон	1	165127.911772	покупка жилой недвижимости	6	недвижимость	неплатежеспособен<br>
15	1	972	26	среднее	1	женат / замужем	0	f	сотрудник	0	116820.904450	строительство собственной недвижимости	5	строительство	неплатежеспособен<br>
16	0	1719	35	среднее	1	женат / замужем	0	f	сотрудник	0	289202.704229	недвижимость	5	недвижимость	неплатежеспособен<br>
17	0	2369	33	высшее	0	гражданский брак	1	m	сотрудник	0	90410.586745	строительство недвижимости	5	строительство	платежеспособен<br>
18	0	4002	53	среднее	1	вдовец / вдова	2	f	пенсионер	0	56823.777243	на покупку подержанного автомобиля	2	автотранспорт	неплатежеспособен<br>
19	0	10038	48	среднее	1	в разводе	3	f	сотрудник	0	242831.107982	на покупку своего автомобиля	5	автотранспорт	платежеспособен<br>


Категоризация.<br>

На мой взгляд необходимо определить является ли клиент платежеспособным. Для определения среднего уровня дохода и стажа использовал метод median(). Далее написал функцию , которая анализирует входные параметры и выдает итоговый статус платежеспособности. И пременил метод apply с параметром axis=1 ( для перехода по всем строкам) ко всему датафрейму. Итоговый вывод - колонка с категориями платежеспособности клинетов на основе предаставленных данных.<br>

Есть ли зависимость между наличием детей и возвратом кредита в срок?<br><br>
data.pivot_table(index=['children'], values='debt', aggfunc='mean').sort_values(by='debt', ascending=True).head(10)<br>
debt<br>
children	<br>
5	0.000000<br><br>
0	0.075453<br>
3	0.082317<br>
1	0.091341<br>
2	0.095145<br>
4	0.097561<br>
20	0.106667<br>
df_with_5_children = data[data['children'] == 5]<br>
print(df_with_5_children.shape)<br>
(9, 15)<br>
Вывод

Есть ли зависимость между наличием детей и возвратом кредита в срок?<br>

Группу клиентов с 5 детьми не буду брать в расчет, таких всего 9 заявок. Для анализа такое количетсво не подойдет. Минимальный процент задолженности по кредиту у группы без детей, макисмальный процент ( 10% шанс возникновения задержки платежа) у группы, где на каждого клиента по 20 детей. Значения для всех групп находятся в одном диапозоне, считаю, что зависимости нет.<br>

data['children'].unique()<br>
array([ 1,  0,  3,  2,  4, 20,  5])<br>
data[data['children'] == 20].count()<br>
children            75<br>
days_employed       75<br>
dob_years           75<br>
education           75<br>
education_id        75<br>
family_status       75<br>
family_status_id    75<br>
gender              75<br>
income_type         75<br>
debt                75<br>
total_income        75<br>
purpose             75<br>
income_type_id      75<br>
target              75<br>
solvency_status     75<br>
dtype: int64<br>
В колонке "Количетсво детей" есть несколько уникальных значений. В том числе, присутствует значение 20, которое слишком сильно "оторвано" от предыдущего значения. Возможно ноль дописан случайно. Приведу значение к корректному виду<br>

data['children'] = data['children'].replace(20,2)<br>
data[data['children'] == 20].count()<br>
children            0<br>
days_employed       0<br>
dob_years           0<br>
education           0<br>
education_id        0<br>
family_status       0<br>
family_status_id    0<br>
gender              0<br>
income_type         0<br>
debt                0<br>
total_income        0<br>
purpose             0<br>
income_type_id      0<br>
target              0<br>
solvency_status     0<br>
level_income        0<br>
dtype: int64
data[data['children'] == 5].count()<br>
children            9<br>
days_employed       9<br>
dob_years           9<br>
education           9<br>
education_id        9<br>
family_status       9<br>
family_status_id    9<br>
gender              9<br>
income_type         9<br>
debt                9<br>
total_income        9<br>
purpose             9<br>
income_type_id      9<br>
target              9<br>
solvency_status     9<br>
level_income        9<br>
dtype: int64<br>
Клиентов у которых 5 детей всего девять, думаю их можно исключить из выборки.<br>

data = data[data.children != 5]<br>
data.pivot_table(index=['children'], values='debt', aggfunc='mean').sort_values(by='debt', ascending=True).head(10)<br>
debt<br>
children	<br>
0	0.075453<br>
3	0.082317<br>
1	0.091341<br>
2	0.095553<br>
4	0.097561<br>
Минимальный процент задолженности по кредиту у группы без детей, макисмальный процент ( 10% шанс возникновения задержки платежа) у группы, где на каждого клиента по 4 детей. Более высокой платежеспособностью обладают клиенты без детей.<br>

Есть ли зависимость между семейным положением и возвратом кредита в срок?<br>
data.pivot_table(index=['family_status'], values='debt', aggfunc='mean').sort_values(by='debt', ascending=True).head()<br>
debt<br>
family_status	<br>
вдовец / вдова	0.064990<br>
в разводе	0.071730<br>
женат / замужем	0.075427<br>
гражданский брак	0.093462<br>
не женат / не замужем	0.097709<br>
Вывод<br>

Есть ли зависимость между семейным положением и возвратом кредита в срок?<br>

При большом количестве потенциальных кредиторов это будет ощутимая разница. Тогда минимальных процент не возврата у группы "вдова/вдовец", а макисмальный у группы "не женат / не замужем.<br>

Есть ли зависимость между уровнем дохода и возвратом кредита в срок?<br>
Для начала определим минимальный и максимальный доход, затем возьмем медианное значение и шаг в стороны по 50000 для определения диапазона со среденим доходом.После напишем функцияю для метода apply(), которая будет принимать на вход значение из стоблца "total_income" и возвращать в новую колонку level_income значение доходности клиента.<br>

min_income = data['total_income'].min()<br>
low_bound = median_income - 50000<br>
high_bound = median_income + 50000<br>
max_income = data['total_income'].max()<br>

def get_income_level(income):<br>
    if min_income < income < low_bound:<br>
        return 'низкий доход'<br>
    elif low_bound < income < high_bound:<br>
        return 'средний доход'<br>
    elif high_bound < income < max_income:<br>
        return 'высокий доход'<br>

data['level_income'] = data['total_income'].apply(get_income_level)<br>
data.head()<br>
children	days_employed	dob_years	education	education_id	family_status	family_status_id	gender	income_type	debt	total_income	purpose	income_type_id	target	<br>solvency_status	level_income<br>
0	1	8437	42	высшее	0	женат / замужем	0	f	сотрудник	0	253875.639453	покупка жилья	5	недвижимость	платежеспособен	высокий доход<br>
1	1	4024	36	среднее	1	женат / замужем	0	f	сотрудник	0	112080.014102	приобретение автомобиля	5	автотранспорт	неплатежеспособен	средний доход<br>
2	0	5623	33	среднее	1	женат / замужем	0	m	сотрудник	0	145885.952297	покупка жилья	5	недвижимость	платежеспособен	средний доход<br>
3	3	4124	32	среднее	1	женат / замужем	0	m	сотрудник	0	267628.550329	дополнительное образование	5	образование	платежеспособен	высокий доход<br>
4	0	3402	53	среднее	1	гражданский брак	1	f	пенсионер	0	158616.077870	сыграть свадьбу	2	свадьба	неплатежеспособен	средний доход<br>
data.pivot_table(index=['level_income'], values='debt', aggfunc='mean').sort_values(by='debt', ascending=True).head()<br>
debt<br>
level_income	<br>
высокий доход	0.071880<br>
низкий доход	0.079678<br>
средний доход	0.085735<br>
Вывод<br>

Есть ли зависимость между уровнем дохода и возвратом кредита в срок?<br>

У клиентов с низким уровнем дохода процент шанса задержки платежа выше чем у остальных групп, минимальный у клиентов с высоким доходом.<br>

Как разные цели кредита влияют на его возврат в срок?<br>
data.pivot_table(index=['target'], values='debt', aggfunc='mean').sort_values(by='debt', ascending=True).head()<br>
debt<br>
target	<br>
недвижимость	0.071421<br>
строительство	0.076882<br>
свадьба	0.079654<br>
образование	0.092616<br>
автотранспорт	0.093371<br>
Вывод<br>

Как разные цели кредита влияют на его возврат в срок?<br>

Минимальный процент невозврата у клиентов, которые берут кредит на недвижимость, а максимальный у "автотранспорт".<br>

Общий вывод<br>

Исходя из полученный результатов, делаю вывод, что предпочтительнее выбирать будущих клиентов из числа потенциальных кредиторов:<br>

с высоким доходом;<br>

без детей или с детьми , но не больше 1 (наличие > 1 ребенка снижает платежеспособность);<br>

состоящие в браке или разведенные, так же вдовы / вдовцы;<br>

с целями имеющими долгосрочные обязательства, например, кредит на покупку недвижимости или строительства<br>
